// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterKubeConfig {
    /**
     * PEM-encoded client certificate for TLS authentication.
     */
    clientCertificate?: pulumi.Input<string>;
    /**
     * PEM-encoded client certificate key for TLS authentication.
     */
    clientKey?: pulumi.Input<string>;
    /**
     * PEM-encoded root certificates bundle for TLS authentication.
     */
    clusterCaCertificate?: pulumi.Input<string>;
    /**
     * Context name to load from the kube config file.
     */
    configContext?: pulumi.Input<string>;
    configContextAuthInfo?: pulumi.Input<string>;
    configContextCluster?: pulumi.Input<string>;
    /**
     * Path to the kube config file.
     */
    configPath?: pulumi.Input<string>;
    /**
     * A list of paths to kube config files.
     */
    configPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The hostname (in form of URI) of Kubernetes master.
     */
    host?: pulumi.Input<string>;
    /**
     * Whether server should be accessed without verifying the TLS certificate.
     */
    insecure?: pulumi.Input<boolean>;
    /**
     * The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
     */
    password?: pulumi.Input<string>;
    /**
     * URL to the proxy to be used for all API requests
     */
    proxyUrl?: pulumi.Input<string>;
    /**
     * Token to authenticate an service account
     */
    token?: pulumi.Input<string>;
    /**
     * The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
     */
    username?: pulumi.Input<string>;
}

export interface ClusterSpec {
    /**
     * Cluster data
     */
    data: pulumi.Input<inputs.ClusterSpecData>;
    /**
     * Cluster description
     */
    description?: pulumi.Input<string>;
    /**
     * If the agent is namespace scoped
     */
    namespaceScoped?: pulumi.Input<boolean>;
}

export interface ClusterSpecData {
    /**
     * Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
     */
    appReplication?: pulumi.Input<boolean>;
    autoUpgradeDisabled?: pulumi.Input<boolean>;
    /**
     * Enable Datadog metrics collection of Application Controller and Repo Server. Make sure that you install Datadog agent in cluster.
     */
    datadogAnnotationsEnabled?: pulumi.Input<boolean>;
    /**
     * Enable this if you are installing this cluster on EKS.
     */
    eksAddonEnabled?: pulumi.Input<boolean>;
    /**
     * Kustomize configuration that will be applied to generated agent installation manifests
     */
    kustomization?: pulumi.Input<string>;
    /**
     * The config to access managed Kubernetes cluster. By default agent is using "in-cluster" config.
     */
    managedClusterConfig?: pulumi.Input<inputs.ClusterSpecDataManagedClusterConfig>;
    /**
     * Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
     */
    redisTunneling?: pulumi.Input<boolean>;
    /**
     * Cluster Size. One of `small`, `medium` or `large`
     */
    size: pulumi.Input<string>;
    /**
     * The version of the agent to install on your cluster
     */
    targetVersion?: pulumi.Input<string>;
}

export interface ClusterSpecDataManagedClusterConfig {
    /**
     * The key in the secret for the managed cluster config
     */
    secretKey?: pulumi.Input<string>;
    /**
     * The name of the secret for the managed cluster config
     */
    secretName: pulumi.Input<string>;
}

export interface InstanceArgocd {
    /**
     * Argo CD instance spec
     */
    spec: pulumi.Input<inputs.InstanceArgocdSpec>;
}

export interface InstanceArgocdSpec {
    /**
     * Instance description
     */
    description?: pulumi.Input<string>;
    /**
     * Argo CD instance spec
     */
    instanceSpec: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpec>;
    /**
     * Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
     */
    version: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpec {
    /**
     * The ability to configure agent permissions rules.
     */
    agentPermissionsRules?: pulumi.Input<pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecAgentPermissionsRule>[]>;
    /**
     * Select cluster in which you want to Install Application Set controller
     */
    appSetDelegate?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecAppSetDelegate>;
    /**
     * Configures Application Set policy settings.
     */
    appsetPolicy?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecAppsetPolicy>;
    /**
     * Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
     */
    assistantExtensionEnabled?: pulumi.Input<boolean>;
    /**
     * Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
     */
    auditExtensionEnabled?: pulumi.Input<boolean>;
    /**
     * Enable ip allow list for cluster agents
     */
    backendIpAllowListEnabled?: pulumi.Input<boolean>;
    /**
     * Default values for cluster agents
     */
    clusterCustomizationDefaults?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults>;
    /**
     * Custom Resource Definition group name that identifies the Crossplane resource in kubernetes. We will include built-in crossplane resources. Note that you can use glob pattern to match the group. ie. *.crossplane.io
     */
    crossplaneExtension?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecCrossplaneExtension>;
    /**
     * Enable Declarative Management
     */
    declarativeManagementEnabled?: pulumi.Input<boolean>;
    /**
     * Extensions
     */
    extensions?: pulumi.Input<pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecExtension>[]>;
    /**
     * Configures the FQDN for the argocd instance, for ingress URL, domain suffix, etc.
     */
    fqdn?: pulumi.Input<string>;
    /**
     * Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
     */
    hostAliases?: pulumi.Input<pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecHostAlias>[]>;
    /**
     * Select cluster in which you want to Install Image Updater
     */
    imageUpdaterDelegate?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecImageUpdaterDelegate>;
    /**
     * Enable Image Updater
     */
    imageUpdaterEnabled?: pulumi.Input<boolean>;
    /**
     * IP allow list
     */
    ipAllowLists?: pulumi.Input<pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecIpAllowList>[]>;
    /**
     * In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
     */
    repoServerDelegate?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecRepoServerDelegate>;
    /**
     * Instance subdomain. By default equals to instance id
     */
    subdomain?: pulumi.Input<string>;
    /**
     * Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
     */
    syncHistoryExtensionEnabled?: pulumi.Input<boolean>;
}

export interface InstanceArgocdSpecInstanceSpecAgentPermissionsRule {
    /**
     * API groups of the rule.
     */
    apiGroups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Resources of the rule.
     */
    resources?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Verbs of the rule.
     */
    verbs?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceArgocdSpecInstanceSpecAppSetDelegate {
    /**
     * Use managed cluster
     */
    managedCluster?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster>;
}

export interface InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster {
    /**
     * Cluster name
     */
    clusterName: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecAppsetPolicy {
    /**
     * Allows per `ApplicationSet` sync policy.
     */
    overridePolicy?: pulumi.Input<boolean>;
    /**
     * Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
     * Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
     *   - Policy `sync`(default): Update and delete are allowed.
     *   - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
     *   - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
     *   - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
     */
    policy?: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults {
    /**
     * Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
     */
    appReplication?: pulumi.Input<boolean>;
    autoUpgradeDisabled?: pulumi.Input<boolean>;
    /**
     * Kustomize configuration that will be applied to generated agent installation manifests
     */
    kustomization?: pulumi.Input<string>;
    /**
     * Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
     */
    redisTunneling?: pulumi.Input<boolean>;
}

export interface InstanceArgocdSpecInstanceSpecCrossplaneExtension {
    /**
     * Glob patterns of the resources to match.
     */
    resources?: pulumi.Input<pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecCrossplaneExtensionResource>[]>;
}

export interface InstanceArgocdSpecInstanceSpecCrossplaneExtensionResource {
    /**
     * Glob pattern of the group to match.
     */
    group?: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecExtension {
    /**
     * Extension ID
     */
    id: pulumi.Input<string>;
    /**
     * Extension version
     */
    version: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecHostAlias {
    /**
     * List of hostnames
     */
    hostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * IP address
     */
    ip: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecImageUpdaterDelegate {
    /**
     * If use control plane or not
     */
    controlPlane: pulumi.Input<boolean>;
    /**
     * If use managed cluster or not
     */
    managedCluster?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster>;
}

export interface InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster {
    /**
     * Cluster name
     */
    clusterName: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecIpAllowList {
    /**
     * IP description
     */
    description?: pulumi.Input<string>;
    /**
     * IP address
     */
    ip: pulumi.Input<string>;
}

export interface InstanceArgocdSpecInstanceSpecRepoServerDelegate {
    /**
     * If use control plane or not
     */
    controlPlane: pulumi.Input<boolean>;
    /**
     * If use managed cluster or not
     */
    managedCluster?: pulumi.Input<inputs.InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster>;
}

export interface InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster {
    /**
     * Cluster name
     */
    clusterName: pulumi.Input<string>;
}

export interface InstanceConfigManagementPlugins {
    /**
     * Whether this plugin is enabled or not. Default to false.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Image to use for the plugin
     */
    image: pulumi.Input<string>;
    /**
     * Plugin spec
     */
    spec: pulumi.Input<inputs.InstanceConfigManagementPluginsSpec>;
}

export interface InstanceConfigManagementPluginsSpec {
    /**
     * The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
     */
    discover?: pulumi.Input<inputs.InstanceConfigManagementPluginsSpecDiscover>;
    /**
     * The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
     */
    generate: pulumi.Input<inputs.InstanceConfigManagementPluginsSpecGenerate>;
    /**
     * The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
     */
    init?: pulumi.Input<inputs.InstanceConfigManagementPluginsSpecInit>;
    /**
     * The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
     */
    parameters?: pulumi.Input<inputs.InstanceConfigManagementPluginsSpecParameters>;
    /**
     * Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
     */
    preserveFileMode?: pulumi.Input<boolean>;
    /**
     * Plugin version
     */
    version?: pulumi.Input<string>;
}

export interface InstanceConfigManagementPluginsSpecDiscover {
    /**
     * A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
     */
    fileName?: pulumi.Input<string>;
    /**
     * Find config
     */
    find?: pulumi.Input<inputs.InstanceConfigManagementPluginsSpecDiscoverFind>;
}

export interface InstanceConfigManagementPluginsSpecDiscoverFind {
    /**
     * Arguments for the find command
     */
    args?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
     */
    commands?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * This does the same thing as `fileName`, but it supports double-start (nested directory) glob patterns.
     */
    glob?: pulumi.Input<string>;
}

export interface InstanceConfigManagementPluginsSpecGenerate {
    /**
     * Arguments of the command
     */
    args?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Command
     */
    commands: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceConfigManagementPluginsSpecInit {
    /**
     * Arguments of the command
     */
    args?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Command
     */
    commands: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceConfigManagementPluginsSpecParameters {
    /**
     * Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
     */
    dynamic?: pulumi.Input<inputs.InstanceConfigManagementPluginsSpecParametersDynamic>;
    /**
     * Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
     */
    statics?: pulumi.Input<pulumi.Input<inputs.InstanceConfigManagementPluginsSpecParametersStatic>[]>;
}

export interface InstanceConfigManagementPluginsSpecParametersDynamic {
    /**
     * Arguments of the command
     */
    args?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
     */
    commands?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceConfigManagementPluginsSpecParametersStatic {
    /**
     * This field communicates the parameter's default value to the UI if the parameter is an `array`.
     */
    arrays?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
     */
    collectionType?: pulumi.Input<string>;
    /**
     * Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
     */
    itemType?: pulumi.Input<string>;
    /**
     * This field communicates the parameter's default value to the UI if the parameter is a `map`.
     */
    map?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Parameter name
     */
    name?: pulumi.Input<string>;
    /**
     * Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
     */
    required?: pulumi.Input<boolean>;
    /**
     * This field communicates the parameter's default value to the UI if the parameter is a `string`.
     */
    string?: pulumi.Input<string>;
    /**
     * Title and description of the parameter
     */
    title?: pulumi.Input<string>;
    /**
     * Tooltip of the Parameter, will be shown when hovering over the title
     */
    tooltip?: pulumi.Input<string>;
}
